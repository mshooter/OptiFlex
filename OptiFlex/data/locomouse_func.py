import os
import csv
import cv2
from OptiFlex.utils.base_func import mk_outdir
from OptiFlex.data.vid_proc import vid_frm_get, frm_split
from OptiFlex.data.lbl_proc import jsl_read, jsl_write

"""Function list:
locomouse_paracsv_read(para_csv):  Read LocoMouse recording parameter CSV file.
locomouse_vproc(vid_file, para_csv):  Process recording data from LocoMouse system to fit machine learning usage.
locomouse_tail_sort(lbl_file, n_tail, vid_width):  Sort and rename multiple tail tags in LocoMouse system label file.
"""


def locomouse_paracsv_read(para_csv):
    """ Read LocoMouse recording parameter CSV file generated by MATLAB function [locomouse_lbl_conv].

    Args:
        para_csv (str): Parameters used in manual labelling, generated by [locomouse_lbl_conv.m], in CSV file.

    Returns:
        tuple[int, int, int, int]:
            frm_init (int): The starting index of LocoMouse frame to be acquired.
            frm_step (int): LocoMouse frame index sampling step.
            frm_stop (int): The last index of LocoMouse frame to be acquired.
            split_pos (int): The pixel position of the LocoMouse side/bottom view border.
    """
    info_value = []    # INIT VAR
    # Read CSV file
    with open(para_csv, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            info_value.append(row['value'])
    # Get default parameter order
    frm_init = int(info_value[0])
    frm_step = int(info_value[1])
    frm_stop = None if info_value[2] == 'None' else int(info_value[2])
    split_pos = int(info_value[3])
    return frm_init, frm_step, frm_stop, split_pos


def locomouse_vproc(vid_file, para_csv):
    """ Process recording data from LocoMouse system to fit machine learning usage.

    Args:
        vid_file (str): Video from LocoMouse system to be defined.
        para_csv (str): Parameters used in manual labelling, generated by [locomouse_lbl_conv.m], in CSV file.

    Returns:
        tuple[int, int]:
            frm_width (int): LocoMouse video file frame width.
            frm_height (int): LocoMouse video file frame height.
    """
    # Get path from file input
    base_path = os.path.split(vid_file)[0]
    # Read parameters from CSV file
    frm_init, frm_step, frm_stop, split_pos = locomouse_paracsv_read(para_csv=para_csv)

    # Extract labelled frames from original video and get all file names
    frm_dir = mk_outdir(base_path + '/frames/', err_msg='Invalid frame output directory, function out!')
    frm_width, frm_height = vid_frm_get(vid_file=vid_file, out_dir=frm_dir,
                                        frm_init=frm_init, frm_step=frm_step, frm_stop=frm_stop)
    frames = [f for f in os.listdir(frm_dir) if f.endswith('.png')]

    # Split extracted frames refer to the 'split_pos' info
    spt_dir = mk_outdir(base_path + '/split_view/', err_msg='Invalid split frame directory, function out!')
    for frm in frames:
        img = cv2.imread(frm_dir + frm, -1)    # cv::ImreadModes - enum -1, cv2.IMREAD_UNCHANGED
        img_sd, img_btm = frm_split(img=img, split_pos=split_pos, mode=1)
        cv2.imwrite(spt_dir + 'sd_' + frm, img_sd)
        cv2.imwrite(spt_dir + 'btm_' + frm, img_btm)

    # Output basic info
    return frm_width, frm_height


def locomouse_tail_sort(lbl_file, n_tail, vid_width):
    """ Sort and rename multiple tail tags in LocoMouse system label file.

    Args:
        lbl_file (str): Labelling file contained with labels from LocoMouse system.
        n_tail (int): {Number of [Tail] label points used in LocoMouse manual labelling.
        vid_width (int): LocoMouse system recorded video file frame width.

    Returns:
    """
    lbl_data = jsl_read(lbl_file)
    mid_width = vid_width >> 1

    # Initiate variables for record label data info
    i = 0
    has_snout = False
    snout_left = None
    tail_index = []
    tail_left = []
    tail_dummy_index = []
    # Getting required label data info
    for lbl in lbl_data:
        # Detect if [Snout] exist in labels
        if lbl['label'] == 'Snout':
            # Dummy label filter
            if (lbl['left'] > 0) and (lbl['left'] is not None) and (lbl['top'] > 0) and (lbl['top'] is not None):
                has_snout = True
                snout_left = lbl['left']
        # Count number of [Tail] labels
        if lbl['label'] == 'Tail':
            # Dummy label filter
            if (lbl['left'] > 0) and (lbl['left'] is not None) and (lbl['top'] > 0) and (lbl['top'] is not None):
                tail_index.append(i)
                tail_left.append(lbl['left'])
            else:
                tail_dummy_index.append(i)
        # Index count
        i += 1

    # Checking variable
    if (len(tail_index) + len(tail_dummy_index)) > n_tail:
        print('Defined [Tail] label number is LESS than existing [Tail] labels, function OUT!')
        exit()

    # Sorting multiple [Tail] labels
    if has_snout:
        if tail_index:
            abs_dist = [abs(snout_left - tl) for tl in tail_left]
            abs_dist, tail_index = zip(*sorted(zip(abs_dist, tail_index)))
            count = 1  # INIT VAR
            for i in tail_index:
                lbl_data[i]['label'] = 'Tail %0.2d' % count
                count += 1
    else:
        if tail_index:
            tail_left, tail_index = zip(*sorted(zip(tail_left, tail_index)))
            if max(tail_left) < mid_width:  # Mouse on left half of image
                count = 1  # INIT VAR
                for i in tail_index:
                    lbl_data[i]['label'] = 'Tail %0.2d' % count
                    count += 1
            else:  # Mouse on right half of image
                count = n_tail  # INIT VAR
                for i in tail_index:
                    lbl_data[i]['label'] = 'Tail %0.2d' % count
                    count -= 1
    # Sort for dummy [Tail] labels
    if not tail_dummy_index:
        count = n_tail  # INIT VAR
        tail_dummy_index.sort(reverse=True)
        for i in tail_dummy_index:
            lbl_data[i]['label'] = 'Tail %0.2d' % count
            count -= 1

    # Write sorted label
    jsl_write(lbl_file, lbl_data)
